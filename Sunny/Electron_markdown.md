## Electron 

#### Make Markdown editor

```
웹 팩에서는 자바스크립트 뿐만 아니라 css, html 등도 함께 번들할 수 있음 !!

npm 스크립트 정의 

빌드 : 웹팩으로 자바스크립트 파일 변환
와치 : 자바스크립트 파일의 벼녕을 감시하는 프로세스를 실행 ! (감시하는 파일 변경시 변환)
스타트 : 일렉트론 실행

에디터 컴포넌트에 텍스트를 입력시 체인지 이벤트 콜백으로 텍스트 전달! ( 텍스트 관리를 부모 컴포넌트가 할 수 있음 )

자바스크립트의 표준에는 이러한 CSS 임포트 기능이 없지만 웹팩과 CSS-LOADER를 활용하면 자바스크립트 코드 내부에서 CSS 임포트 가능! ㅅ

CSS파일에 동일한 CSS 선택자가 정의되어 있어도 다른 CSS 클래스 이름이 생성가능! 

marked() 함수는 마크다운 문자열을 매개변수로 전달하면 html로 변환해서 반환해줌! / 마크디드를 사용할 때 위험한 코드를 실행시키지 않도록 sanitize 트루로 하여 html 문법이 아닌 보호된 문법으로 나오게 해줌! 

리액트에서는 보안상의 문제로 html로 곧바로 전달하는 것이 불가능하여 다른 곳에서 넘겨서 보내줘야함 !

대화상자 출력시에는 일렉트론이 제공하는 다이아로그 모듈을 사용함 / 운영 체제가 제공하는 대화 상자를 사용할 수 있게 해주는 모듈! 
일렉트론은 보안상의 문제로 렌더러 프로세스에서 운영체제의 api 호출할 수 없게 막아놓아서 메인 프로세스에서 다이아로그 모듈을 사용해야함! (리모트 모듀를 사용하면 렌더러에서도 사용)

메인 프로세스와 렌더러 프로세스는 각각 독립적인 프로세스로 동작 / 직접적으로 메모리 공간을 서로 참조 x => 통신하려면 IPC 사용해야함!

메인 프로세스는 일렉트론을 실행해서 처음 실행되는 프로세스로 일렉트론 어플리케이션이 종료될 때까지 유지!
렌더러 프로세스는 메인 프로세스가 브라우저윈도우 인스턴스를 저장하는 동안에만 작동함! / 브라우저 윈도우 인스턴스 제거시 같이 종료됨!

렌더러 프로세스는 독립되어 동작 / 서로의 존재를 인식할 수 없음 / 모든 렌더러 프로세스를 관리하는 것이 메인 프로세스의 역할!!

메인 프로세스의 각각의 렌더러 프로세스끼리 통신을 할 때에는 IPC라는 기능을 사용함! 

일렉트론의 IPC의 경우에는 자바스크립트 API로 래핑되어 있어 사용이 쉬움.

ipcRenderer / Renderer 프로세스 / 메인 프로세스에서 메세지를 수신하고 메인 프로세스로 메세지를 송신!
ipcMain / Main프로세스 / 렌더러 프로세스에서 메세지를 수신함
webContents / Main프로세스 / 렌더러 프로세스로 메세지를 송신함
remote / Renderer 프로세스 / 메인 프로세스에서 저장한 모듈에 접근합니다. 

렌더러 프로세스의 리소스는 일렉트론 모듈과 노드 js의 자체젝인 기능을 사용하지 않는다면 일반적인 웹 브라우저에서도 실행가능 
ipc 통신처럼 일렉트론이 제공하는 자체적인 기능을 사용해야할 때도 있으므로 고민이 필요함

ipc 랜더 모듈 
ipc 랜더 모듈을 렌더러 프로세스에서 사용함 / 메인 프로세스로부터 메세지를 수신하는 기능과 메인 프로세스로 메세지를 송신하는 기능을 모두 가지고 있음!
on (첫번째 매개변수에 지정한 채널 구독을 시작) / once (on과 마찬가지로 동작하지만, 리스너가 한번만 동작한 이후 구독이 해제)
removeListner (지정한 채널의 리스너 구독을 해제) / removeAllListener (지정한 채널의 모든 리스너 구독을 해제)
send(지정한 채널에 이벤트를 발행 / 두번쨰 매개 변수 이후의 매개변수로 송신할 값 설정) / sendSync(send와 마찬가지로 동작하지만 등기 통신을 함)
sendToHost(send와 마찬가지로 동작/ 메인 프로세스가 아니라 렌더러 프로세스에서 소우하는 웹뷰가 대상이 됌!)

ipc 랜더러 모듈을 사용해 메인 프로세스로 이벤트를 발행할 때에는 비동기 통신과 동기 통신을 모두 사용 가능 (ipcRender.send = 비동기 / ipcRender.sendSyn => 동기 통신이 됌!)

ipcRender.sendSync 사용시 메인 프로세스 측에서 받은 이벤트 객체의 리턴 벨류라는 속성에 설정된 값이 전달된 값입니다. 
메인 프로세스에서 응답을 받을 때까지 해당 메서드를 발행한 렌더러 프로세스는 블록되므로 메세지 핸들링 시 실수하면 화면이 응답 없음 상태가 되어 있음! 

ipc 메인 모듈

메인 프로세스에서 사용 / 렌더러 프로세스로부터 메세제리 수신 / 렌더러 모듈은 메세지 전송도 지원하지만 메인 모듈은 수신만 지원함!!

ipcMain.on(첫번째 매개 변수에 지정한 채널을 구독) / ipcMain.once (on과 같은 동작을 하지만 리스너가 한 번만 동작함)
ipcMain.removeListener(지정한 채널의 리스너 구독을 해제) / ipcMain.removeAllListener(지정한 채널의 모든 리스너 구독을 해제)

webContents.send() 메서드

브라우저윈도의 인스턴스 = webContents 모듈

메인 프로세스 측에서도 사용함! / send() 메서드 제공 / 메인 프로세스에서 렌더러 프로세스로 메세지 전송 가능 (ipc렌더러와 ipc메인 모듈의 send() 메서드와 같음) 

remote 모듈
렌더러 프로세스에서 사용 / 메인 프로세스 측의 모듈에 접근할 떄 사용!/ 다이아로그 모듈 또는 메인 모듈은 일반적으로 메인 프로세스에서만 사용 가능  
리모드 모듈을 사용하면 렌더러 프로세스에서도 사용가능 

일렉트론 모듈의 리모트.모듈네임 형태로 사용 !!

require (main 프로세스 측의 함수 또는 객체 호출 ) / getCurrentWindow (호출한 렌더러 프로세스의 브라우저윈도우 인스턴스를 추출)
getCurrentWebContents(호출한 렌더러 프로세스의 웹컨텐츠 인스턴스를 추출) / getGlobal(메인 프로세스의 글로벌 변수를 추출)

리모트 모듈을 통해 추출한 객체는 레넏러 프로세스에서 저장하는 동안 가비지 컬렉션 대상에서 제외 
다만 기본 자료값을 사용할 때에는 값 복사가 이루어지므로 메모리 누수를 걱정하지 않아도 됨!

dialog 모듈 

dialog 모듈을 사용하면 운영체제가 제공하는 대화 상자를 출력할 수 있음 / 운영체제의 api는 보안상의 문제로 렌더러 모듈에서 직접 호출하는 것이 금지되어 있음 따라서 다이로그 모듈은 메인 프로세스 측에서만 사용 가능!

showOpenDialog(파일 열기 대화 상자를 출력 ) / showSaveDialog (파일 저장 대화 상자를 출력함)
showMessageBox(메세지 박스 대화 상자를 출력함) / showErrorBox(오류 대화 상자를 출력함)

showOpenDialog, showSaveDialog, showMessageBox 메서드의 첫 번째 매개 변수에는 브라우저윈도우 객체를 전달함, 이를 전달하면 상부에 붙은 형태로 대화 상자가 열림! (맥에서만 가능!)

showOpenDialog 메서드 (기본적으로 메인 프로세스 위에서 동기적으로 실행 / 성공한 경우에는 선택한 파일 경로의 배열을 반환 / 실패시 정의 되지 않은 값이 반환 / 다만 콜백 옵션을 지정 시 비동기적으로 실행 이 때는 콜백의 첫 번째 매개 변수로 실행결과가 전달됨!)

title(대화상타 타이틀 지정) / defaulPath(대화 상자 열었을 때 기본경로 지정) / buttonLabel (버튼의 레이블을 지정합니다)
filters (대화 상자의 필터를 지정합니다) / properties(대화 상자의 기능을 지정합니다.)
normalizeAccessKeys(플랫폼들의 키보드 단축키 표준화 여부를 지정함) / callback(파일을 선택한 이후에 실행할 콜백을 지정합니다.)

filters 옵션으로는 파일 확장자 설정 가능 !! 

properties 옵션 속성
openfile(파일을 대상으로 함) / openDirectory (폴더를 대상으로 함) /multiSelections(여러 개 선택을 가능하게 함) / createDirectory 폴더 생성을 가능하게 함 / showHiddenFiles (숨긴 파일 출력하게 함!)
각각의 기능은 서로 충돌하지 않으므로 문자열 배열로 지정할 수 있음. 하지만 플랫폼의 제약을 받긴함 !!

showSaveDialog 메서드

title(대화 상자의 타이틀 지정) / defaultPath(대화 상자를 열었을 때 기본 경로를 지정합니다) / buttonLabel (버튼의 레이블을 지정)
filters(대화 상자의 필터를 지정함) / callback (파일을 선택한 이후에 실행할 콜백을 지정합니다. )

showMessageBox() 메서드

type(출력할 대화 상자의 종류 지정) / buttons(대화 상자에 출력할 버튼을 지정) / defaultid( 대화 상자를 출력한 때에 기본적으로 선택 상태가 될 버튼의 인덱스를 지정함) / title (대화 상자를 타이틀을 지정함) / message(대화 상자에 출력할 메세지 지정) / detail (대화 상자에 출력할 메세지의 상세를 지정함) / icon ( 대화 상자의 아이콘을 지정함) / cancelld ( 대화 상자가 취소되었을 때반환할 id를 지정함) / callback (대화 상자 위에서 버튼을 클릭한 뒤에 실행할 콜백을 지정함 ) 

타입 옵션에는 메세지 박스의 종류에 따라 none info,error,question,warning 을 지정할 수 있으며, 버튼 옵션에는 배치할 버튼의 레이블 문자열을 배열로 지정함, 설치한 버튼을 지정 순서대로 인덱스가 id로 붙음, callback 옵션을 지정하지 않으면 동기처리가 되며, 지정하면 비동기 처리가 되는 것은 다른 것과 같지만 메서드의 반호나 값이 아이디라는 점이 다름! 

this.window.webContents.send("Request_text"); 에서 렌더러 프로세스에 텍스트를 요구하는 이벤트 발행, ipcMain.once 부분에서 렌더러 프로세스에서의 응답 이벤트를 받게 됌(비동기 처리 이므르 프로미스 객체로 반환 ) / 렌더러 프로세스 측에는 리퀘스트 텍스트 이벤트를 전달하게 하며 리플라이 텍스트 이벤트로 텍스트 반환처리 함. 

리액트는 Component가 뷰 위에 마운트 될 때와 언마운트 되기 직전을 나타내는 ComponentDidMount() 메서드와 componentWIllUnmount() 메서드를 제공함 / 컴포넌트디드마운트 메세드에서 이벤트 구독을 시작 컴포넌트윌언마운트 메서드에서구독을 해제하게 됨 !! 

printToPDF() 메서드 
메인 프로세스에서 렌더러 프로세스로의 메세지 전송에 사용한 웹컨텐츠 모듈에는 IPC를 통해 메세지를 전송하는 기능 외에도 Webcontents 모듈을 사용하면 메인 프로세스 쪽에서도 렌더러 프로세스의 콘텐츠를 조작할 수 있으며, 렌더러 프로세스 측의 생명주기를 훅 할 수 있음

프린트투피디에프는 pdf로 인쇄를 해주는 메스드임 ! 

marginsType(PDF 여백 지정 )/ Pagesize(페이지 크기 지정) / printBackground(css로 지정된 배경도 함꼐 인쇄할지 지정) / printSelectionOnly(선택한 요소만을 인쇄할 지 지정) / landScape(가로 방향으로 인쇄)

marginsType에는 0/1/2 (기본/없음/최소) / pageSize는 a3,a4,a4,Legal,Letter,Tabloid 같이 용지 크기를 조정 가능!

pdf 인쇄 기능은 pdf 인쇄 페이지 전용 렌더러 프로세스를 실행 / 렌더링 결과를 웹 컨텐츠 모듈을 통해 메인 프로세스에서 인쇄하도록 함 !

url 링크를 외부 브라우저를 사용해서 열기

shell (일렉트론에서 파일 또는 URL를 눌렀을 때 기본 어플리케이션이 실행되게 만들려면 shell 모듈을 사용)

showiteminFolder (파일 시스템 오픈) / openitem (파일을 엽니다.) / openExternal (URL을 엽니다.) / moveitemToTrash(파일을 휴지통에 보냄) / beep(비프음을 냄) / [writeShortcutLink(바로 가기를 생성/변경합니다. ) / readShortcuLink(바로가기 정보 읽음) => 윈도우에서만 사용가능함]

webcontents api => https://electron.atom.io/docs/api/web-contents!!



```